import struct
import sys
import random
from mersenne_twister import MersenneTwister
import util
import time

class MersenneCipher:
    def cipher(self, text, seed):
        self.mt = MersenneTwister(seed)
        enc = ''
        length = len(text)
        for c in xrange(0, length, 4):
            random_number = self.mt.next()
            random_bytes = struct.pack('>I', random_number)

            for i in xrange(4):
                if c + i == length:
                    break
                enc += chr(ord(random_bytes[i]) ^ ord(text[c+i]))
        return enc

    def encrypt(self, text, seed):
        return self.cipher(text, seed)

    def decrypt(self, text, seed):
        return self.cipher(text, seed)


def random_cipher(text):
    text = util.random_string(random.randint(42, 1024)) + text
    return MersenneCipher().encrypt(text, random.randint(0, 65535))

def update_progress(done, total):
    sys.stdout.write('\b'*4)
    progress = str(int(100.0*done/total))
    text = (3 - len(progress)) * ' ' + progress + '%'
    sys.stdout.write(text)
    sys.stdout.flush()

def recover_seed(ciphertext, known_text):
    known_length = len(known_text)
    padding = len(ciphertext) - known_length

    rounded_padding = padding % 4
    if rounded_padding != 0:
        rounded_padding = 4 - rounded_padding

    # Start of our known text
    known_start = padding + rounded_padding
    known_end = padding + rounded_padding + 8
    known = ciphertext[known_start:known_end]

    # Convert them to numbers which were generated by rng
    t = util.string_xor(known, known_text[-8:])
    known_a = struct.unpack(">L", t[:4])[0]
    known_b = struct.unpack(">L", t[4:])[0]

    for i in xrange(65536):
        update_progress(i, 65536)
        mt = MersenneTwister(i)
        for ignore in xrange(padding/4):
            mt.next()
        for check in xrange(known_length + 5):
            if mt.next() == known_a:
                if mt.next() == known_b:
                    return i

    return "FAILED"

def generate_reset_token():
    now = int(time.time())
    return (now, MersenneCipher().encrypt('password reset token string', now).encode('hex'))

def verify_reset_token(time, reset_token):
    return MersenneCipher().encrypt('password reset token string', time).encode('hex') == reset_token

if __name__ == '__main__':
    text='''Fly on little wing,
Yeah yeah, yeah, little wing'''

    mc = MersenneCipher()
    enc = mc.encrypt(text, 42)
    dec = mc.decrypt(enc, 42)
    print 'Encoding and decoding a string'
    print 'Encrypted text: %s' % (repr(enc))
    print 'Decrypted text: %s\n' % (repr(dec))

    print 'Encoding a string with random seed and finding out the seed'
    known_text = 'a'*16
    print 'Recovering seed... wait\n'
    print 'Recovered seed as: %s\n' % recover_seed(random_cipher(known_text), known_text)

    print 'Generating a password token and verifiying it'
    gen_time, reset_token = generate_reset_token()
    print 'Generated reset token: %s' % reset_token

    print 'Verification on reset token: %s' % verify_reset_token(gen_time, reset_token)
